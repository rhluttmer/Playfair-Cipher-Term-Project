

New idea: double backtracking
place all row column bits
then once all of those are placed, call backtracking to fill holes in with letters





Pseudocode:
1. Make dictionary of plaintext pairs (keys) that map to ciphertext pairs (values)
2. Go through all key-value pairs in dict, see if any have a letter shared
between key and value. This means they are in row or column.
3. Have list/set of sequences that appear in a row or column.
4. Push the list together. For example, if have OPQ and PQR make it OPQR.
can only do this with two letters in common, because just OPQ and QST could be
QST going down.

4.3. Loop through try to find AB -> YZ -> ??? tells you whether rectangle
or row/col encryption


Implemented up to here

Okay so I have things that are in rows / cols chronologically
And I have things that must be in rows but are out of order
If there are two common letters, then they are describing same thing

make list with letter instances

It says letter preceding (in row), letter succeeding, row sharing letters,
non row sharing letters

Note: Technically, the letter representation loses a little info
Because could know letters were in row but now just know succeed proceed
not in which direction


4.5. Look for triplets that must be in a row together. For example if
AB -> YZ -> (something with A or B but not both) then all letters are
in row because a rectangle would encode back to AB. 

5. Place the longest string (or a string of length 3) if no longest.
This can be placed anywhere because of how playfair works.
6. Then it becomes a backtracking problem. But can be strategic by first
trying out pairs that have letters in common with what has already been placed.
Probably therefore good to have set of letters placed and letters remaining.

Again to be strategic, favor stuff that's more alphabetical.

NOTE: at end, can put the rows in the order. First do it so that each particular
row is in as much alphabetical order as possible, then only the top rows
should be out of alphabetical order so make those ones the top.



        Idea here:
        - Place succeeding letter, if the succeeding letter is also inSameRow
        then it has to work, you would either place it if room, or check that
        it had wrapped around correctly. 
        - If no solution with succeeding letter in row, it has to be below
        in column (or wrapped around)
        - Once succeeding letter is placed, assuming placement is still needed
        everywhere else, then use function to find order to loop through
        - Specifically, should go through row partners first
        - Also a check here to make sure leaving enough room for row partners
        
        


Stupid approach:
1. Make dict with which letters each letter encrypts to. Each set
can have at most 5 letters. 
2. Then put one letter down at the top corner (preferably letter with the biggest set)
3. Now take a letter in letter 1's set, and loop through 5 locations to put
it, like a backtracking problem. 
4. When you take the last letter from letter 1's set, then start placing
letters that a letter already on the board encrypts to. 

Problem: doesn't consider interaction between two plaintext letters. Likely
end up with board where every letter can encrypt to right things 
but letter pairs don't work well together



Very brute force way:
1. Place A on the top left corner (there's always a way that allows this)
2. Loop through the list (moving along rows), placing letters
3. Also have a set to keep track of which letters have been placed.
4. Before placing a letter, check that any digraph key-value pair which
has all letters in board encrypts the right way. 

Can add to legal function. Use the dict of what the things map to. Then when 
placing letter, look at what's in row. At least to decide which one is
left to place?

idea to improve bad crack table: start by placing v. and then start by
trying letters that are later alphabetically. Likely, the key word doesn't have
v, w, x, y, z, so then get that whole row placed first. It doesn't improve
worst case runtime, but it probably improves average runtime