

Pseudocode:
1. Make dictionary of plaintext pairs (keys) that map to ciphertext pairs (values)
2. Go through all key-value pairs in dict, see if any have a letter shared
between key and value. This means they are in row or column.
3. Have list/set of sequences that appear in a row or column.
4. Push the list together. For example, if have OPQ and PQR make it OPQR.
can only do this with two letters in common, because just OPQ and QST could be
QST going down.

4.3. Loop through try to find AB -> YZ -> ??? tells you whether rectangle
or row/col encryption


Implemented up to here

Okay so I have things that are in rows / cols chronologically
And I have things that must be in rows but are out of order
If there are two common letters, then they are describing same thing

make list with letter instances

It says letter preceding (in row), letter succeeding, row sharing letters,
non row sharing letters


4.5. Look for triplets that must be in a row together. For example if
AB -> YZ -> (something with A or B but not both) then all letters are
in row because a rectangle would encode back to AB. 

5. Place the longest string (or a string of length 3) if no longest.
This can be placed anywhere because of how playfair works.
6. Then it becomes a backtracking problem. But can be strategic by first
trying out pairs that have letters in common with what has already been placed.
Probably therefore good to have set of letters placed and letters remaining.

Again to be strategic, favor stuff that's more alphabetical.


Stupid approach:
1. Make dict with which letters each letter encrypts to. Each set
can have at most 5 letters. 
2. Then put one letter down at the top corner (preferably letter with the biggest set)
3. Now take a letter in letter 1's set, and loop through 5 locations to put
it, like a backtracking problem. 
4. When you take the last letter from letter 1's set, then start placing
letters that a letter already on the board encrypts to. 

Problem: doesn't consider interaction between two plaintext letters. Likely
end up with board where every letter can encrypt to right things 
but letter pairs don't work well together



Very brute force way:
1. Place A on the top left corner (there's always a way that allows this)
2. Loop through the list (moving along rows), placing letters
3. Also have a set to keep track of which letters have been placed.
4. Before placing a letter, check that any digraph key-value pair which
has all letters in board encrypts the right way. 

Can add to legal function. Use the dict of what the things map to. Then when 
placing letter, look at what's in row. At least to decide which one is
left to place?

